---
title: "Section_A"
subtitle: "https://dcsuh.github.io/mappingInR/"
output: html_document
---

```{r global options, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(sf)
library(terra)
library(spData)
library(spDataLarge)
```


# Data types

Geographic data can be broken down into two fundamental data models: **vector** data and **raster** data. It is vital to understand the differences between vector and raster data because we handle them in different ways.

### Vector Data

Vector data consist of point, lines, and polygons. The point is the most fundamental of the three since lines and polygons are simply points that have been connected. Vector data are often used to represent meaningful and tangible structures such as a bus stop (point), a road (line), or a county (polygon). The types of maps that we regularly use in our lives are often visualizations of vector data.


### Raster Data

Raster data can be thought of as a grid of cells. These cells are analogous to the pixels that make up an image and are consequently often referred to as pixels. Raster data are commonly used to represent continuous data over a spatial area such as elevation or temperature. 


## Packages

There are a variety of packages for working with spatial data and these have improved over the years. The most up-to-date packages and the ones we will be focusing on for this workshop are 'sf' for vector data and 'terra' for raster data. In addition, we will be using some packages that will load in datasets for our exercises. These are 'spData' and 'spDataLarge'.


## Coordinate Reference Systems

Before we move any further, it is also vital that you understand Coordinate Reference Systems (CRS). Broadly speaking, coordinate reference systems define how the spatial elements of the data relate to the surface of Earth (or any other celestial body you may be studying).

CRS's can be either geographic or projected. Most of us are already familiar with the conventions of a geographic CRS. Any geographic CRS uses longitude and latitude to describe any location on the Earth's surface. However, not all geographic CRS's are made alike and each must make different assumptions about the Earth's surface. 

The most important thing to understand about CRS's is that these should be consistent throughout your analysis. Unfortunately, there is no universal standard for CRS because each CRS has its own advantages and disadvantages. Identification of CRS's can also differ but we recommend using either Spatial Reference System Identifier (SRID) or well-known-text (WKT2). For the purposes of the exercises in this workshop, we will make sure that CRS's are appropriately used, but this is something you will need to manage in your own projects, especially when gather data from different sources. For more in depth knowledge on how to identify and change CRS's please see section 2.4 and chapter 6 of the online textbook.

## Units

Another aspect of working with spatial data that needs to be consistent are units. Attribute data and CRS's can all be using different units which will be problematic for analysis. Again, we will ensure that units are appropriate during this workshop, but you will have to monitor this closely in your own work. Additional information on the subject can be found in section 2.5 of the online textbook.


## Vector Data and simple features

'sf' stands for simple features which is an open standard for working with vector geometry data. Simple features can support all common vector geometry types such as points, lines, polygons and the 'multi' versions of each of these. Geometry collections are also supported which can include multiple data types in one object.

Let's start by looking at the 'world' dataset from the 'spData' package.

```{r}
class(world)
names(world)
```

Note that world is an object of class "sf" and that the data include a column for "geom". "sf" can be simply understood as a regular data frame with an added geom column containing all the geometry data you will need. This column might not always be called "geom" but it will usually have a similar name such as "geometry".

Let's use 'plot' from the 'sf' package to quickly visualize the data from 'world'
```{r}
plot(world)
```
cool map!

## A note on simple features and the 'sf' package.

'sf' is not the first package that has been primarily used for working with spatial data in R. 'sp' is a package with similar functionality but is being superseded by 'sf'. Because 'sf' is newer you might find that some packages don't currently support 'sf' objects but will support 'sp' objects. However, many packages are beginning to adapt to 'sf' and there are already a number of mapping packages that are set up for an 'sf' workflow. We'll focus on those packages later on in the workshop.

Take some time now to play around with plot() and the 'world' data. You should find that it is already pretty intuitive to use to make some simple maps. Run this example code and then describe how the second map is different than the first and how this is designated in the code. After that, spend some time to make a different map of your own and show it to somebody.

```{r}
plot(world["pop"])

world_asia <- world[world$continent == "Asia", ]
asia <- st_union(world_asia)

plot(world["pop"], reset = FALSE)
plot(asia, add = TRUE, col = "red")
```

## Geometry types

Geometries are the basic building blocks of simple features. Simple features in R can take on one of the 17 geometry types supported by the 'sf' package. We will be focusing on the most common types: points, linestring, polygon, multipoint, multilinestring, multipolygon, and geometrycollection.

Geometry types will be encoded using either a hexadecimal code known as well-known binary (WKB) or a human-readable string known as well-known text (WKT).

add examples here for the different geometry types???


## Simple feature geometries

Simple feature geometries will be represented by class 'sfg' and these are the geometries that will be in the 'geom' column of an 'sf' object. You usually won't have to worry about creating 'sfg' objects on your own since they will be provided by a file that includes all the spatial data. However, it is still important to understand the basics of 'sfg'. A more detailed description can be found in the online textbook. 

'sfg' objects will be made from one of three base R data types:
1. A numeric vector: a single point
2. A matrix: a set of points, where each row represents a point, a multipoint or linestring
3. A list: a collection of objects such as matrices, multilinestrings or geometry collections

## Simple feature columns

One sfg object contains only a single simple feature geometry. A simple feature geometry column 'sfc' is a list of sfg objects, which is additionally able to contain information about the coordinate reference system in use. 'sfc' represents the geometry column in 'sf' data frames. 'sfc' can contain multiple simple feature geometries and these will usually be of the same type but they do not have to be. However, it is important that all the geometries are of the same CRS since 'sfc' can contain information about the CRS. 

add example here for checking the CRS and making sure it is the same? This seems like a point where people might get somewhat lost.


## 'sf' class
simple feature geometries and simple feature geometry columns make up all of the important spatial information that we want. Usually, though, we also want to associate these data with non-spatial data known as attributes. Objects of class 'sf' accomplish these by combining attribute data with 'sfc' objects. This results in 'sf' objects which can be treated like regular data frames with an added column for spatial data. When working with vector data, most of your analysis will likely be based off of the final 'sf' objects.

add example here for actually making an sf object by combining a regular data frame and an sfc?


## Raster data and 'terra'

The 'terra' package provides an extensive set of functions to create, read, export, manipulate and process raster datasets. 'terra' is useful because it includes many basic functions as well as advanced functions for working with raster data. 'spDataLarge' includes raster datasets that we can use to learn some of these functions.

Read in this raster with this code chunk.
```{r}
raster_filepath = system.file("raster/srtm.tif", package = "spDataLarge")
my_rast = rast(raster_filepath)
```

Type the name of the raster you just made into the console and answer the following questions.

What is the class of the object?
What are the dimensions?
What CRS is being used?

All raster objects will include a header that includes all of this information in addition to the actual data being stored.

Similar to 'sf', terra also has a basic function for plotting which is also called 'plot'. Plot the raster object below.

```{r}

```


## Raster Classes

The 'SpatRaster' class is what we will be using to represent raster objects. You will usually be reading raster files in from online servers, but you can also make these manually on your own. Below is an example of some code that will make a raster object of class 'SpatRaster'

```{r}
new_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, 
                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
                  vals = 1:36)
```

'SpatRaster's can also handle rasters with multiple layers and those layers can be subsetted using terra:subset() and combined using c().


### Glossary?
vector
raster
CRS
geometry type
'sf' object
'sfg' object
online textbook


### Exercises


E1. Use summary() on the geometry column of the world data object. What does the output tell us about:

```{r}
summary(world$geom)
```


Its geometry type? multipolygon
The number of countries? 177
Its coordinate reference system (CRS)? epsg:4326


E2. Run the code that ‘generated’ the map of the world in Section 2.2.4 Base plot arguments. Find two similarities and two differences between the image on your computer and that in the book.

```{r}
plot(world["continent"], reset = FALSE)
cex = sqrt(world$pop) / 10000
world_cents = st_centroid(world, of_largest = TRUE)
plot(st_geometry(world_cents), add = TRUE, cex = cex)
```
Similarities: colors and circle sizes
Differences: no gridlines and projection looks different

What does the cex argument do (see ?plot)? cex is a scaling factor for characters and symbols
Why was cex set to the sqrt(world$pop) / 10000? This was to standardize population size
Bonus: experiment with different ways to visualize the global population.
```{r}
plot(world["continent"], reset = FALSE)
cex = sqrt(world$pop) / 10000
world_cents = st_centroid(world, of_largest = TRUE)
plot(st_geometry(world_cents), add = TRUE, cex = cex)
```



E3. Use plot() to create maps of Nigeria in context (see Section 2.2.4 Base plot arguments).
Adjust the lwd, col and expandBB arguments of plot().
Challenge: read the documentation of text() and annotate the map.
```{r}
Nigeria <- world[world$name_long == "Nigeria", ]
plot(st_geometry(Nigeria), reset = FALSE, lwd = 10, col = "blue", expandBB = c(0.5,0,0,0))
text(10, labels = "hello")
```



E4. Create an empty SpatRaster object called my_raster with 10 columns and 10 rows. Assign random values between 0 and 10 to the new raster and plot it.
```{r}
my_raster <- rast(nrows = 10, ncols = 10, resolution = 0.5, 
                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
                  vals = 0:10)
plot(my_raster)
```



E5. Read-in the raster/nlcd.tif file from the spDataLarge package. What kind of information can you get about the properties of this file?
```{r}
nlcd <- rast(system.file("raster/nlcd2011.tif", package = "spDataLarge"))
nlcd
plot(nlcd)
```

